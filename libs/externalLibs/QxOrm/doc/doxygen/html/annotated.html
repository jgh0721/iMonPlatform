<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QxOrm: Class List</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="logo_qxorm.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">QxOrm
   &#160;<span id="projectnumber">1.2.5</span>
   </div>
   <div id="projectbrief">C++ Object Relational Mapping library</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li class="current"><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('annotated.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Class List</div>  </div>
</div>
<div class="contents">
<div class="textblock">Here are the classes, structs, unions and interfaces with brief descriptions:</div><table>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1memory_1_1____debug__new__counter.html">qx::memory::__debug_new_counter</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1memory_1_1____debug__new__recorder.html">qx::memory::__debug_new_recorder</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1memory_1_1____nvwa__compile__time__error_3_01true_01_4.html">qx::memory::__nvwa_compile_time_error&lt; true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1memory_1_1mem__pool__base_1_1___block__list.html">qx::memory::mem_pool_base::_Block_list</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1memory_1_1bool__array_1_1___element.html">qx::memory::bool_array::_Element</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1any__cast__dynamic.html">qx::any_cast_dynamic&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1any__cast__dynamic_3_01boost_1_1shared__ptr_3_01_t_01_4_01_4.html">qx::any_cast_dynamic&lt; boost::shared_ptr&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1any__cast__dynamic_3_01_q_shared_pointer_3_01_t_01_4_01_4.html">qx::any_cast_dynamic&lt; QSharedPointer&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1any__cast__dynamic_3_01qx_1_1dao_1_1ptr_3_01_t_01_4_01_4.html">qx::any_cast_dynamic&lt; qx::dao::ptr&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1any__cast__dynamic_3_01_t_01_5_01_4.html">qx::any_cast_dynamic&lt; T * &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1archive__wide__traits.html">qx::trait::archive_wide_traits&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1serialization_1_1detail_1_1base__class.html">qx::serialization::detail::base_class&lt; Base &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1serialization_1_1detail_1_1base__class_3_01qx_1_1trait_1_1no__base__class__defined_01_4.html">qx::serialization::detail::base_class&lt; qx::trait::no_base_class_defined &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1memory_1_1bool__array.html">qx::memory::bool_array</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1memory_1_1class__level__lock.html">qx::memory::class_level_lock&lt; _Host, _RealLock &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_collection_1_1compare_key_value.html">qx::QxCollection&lt; Key, Value &gt;::compareKeyValue&lt; bIsPointer, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_collection_1_1compare_key_value_3_01true_00_01dummy_01_4.html">qx::QxCollection&lt; Key, Value &gt;::compareKeyValue&lt; true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1construct__ptr.html">qx::trait::construct_ptr&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::construct_ptr&lt;T&gt;::get(T &amp; t) : instantiate a new pointer, support both nude-pointer and smart-pointer of boost, Qt and QxOrm libraries </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1construct__ptr_3_01boost_1_1intrusive__ptr_3_01_t_01_4_01_4.html">qx::trait::construct_ptr&lt; boost::intrusive_ptr&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1construct__ptr_3_01boost_1_1scoped__ptr_3_01_t_01_4_01_4.html">qx::trait::construct_ptr&lt; boost::scoped_ptr&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1construct__ptr_3_01boost_1_1shared__ptr_3_01_t_01_4_01_4.html">qx::trait::construct_ptr&lt; boost::shared_ptr&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1construct__ptr_3_01_q_shared_pointer_3_01_t_01_4_01_4.html">qx::trait::construct_ptr&lt; QSharedPointer&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1construct__ptr_3_01qx_1_1dao_1_1ptr_3_01_t_01_4_01_4.html">qx::trait::construct_ptr&lt; qx::dao::ptr&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_sql_relation_1_1create_item___helper.html">qx::QxSqlRelation&lt; DataType, Owner &gt;::createItem_Helper&lt; bIsContainer, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_sql_relation_1_1create_item___helper_3_01true_00_01dummy_01_4.html">qx::QxSqlRelation&lt; DataType, Owner &gt;::createItem_Helper&lt; true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1archive__wide__traits_1_1cvt_q_byte_array.html">qx::trait::archive_wide_traits&lt; T &gt;::cvtQByteArray&lt; isWide, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1archive__wide__traits_1_1cvt_q_byte_array_3_01true_00_01dummy_01_4.html">qx::trait::archive_wide_traits&lt; T &gt;::cvtQByteArray&lt; true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1archive__wide__traits_1_1cvt_q_string.html">qx::trait::archive_wide_traits&lt; T &gt;::cvtQString&lt; isWide, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1archive__wide__traits_1_1cvt_q_string_3_01true_00_01dummy_01_4.html">qx::trait::archive_wide_traits&lt; T &gt;::cvtQString&lt; true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1cvt_1_1detail_1_1_qx_string_cvt_generic_1_1cvt_q_variant.html">qx::cvt::detail::QxStringCvtGeneric&lt; T &gt;::cvtQVariant&lt; isQVariantCompatible, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1cvt_1_1detail_1_1_qx_string_cvt_generic_1_1cvt_q_variant_3_01true_00_01dummy_01_4.html">qx::cvt::detail::QxStringCvtGeneric&lt; T &gt;::cvtQVariant&lt; true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1memory_1_1delete__object.html">qx::memory::delete_object</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1memory_1_1dereference.html">qx::memory::dereference</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1memory_1_1dereference__less.html">qx::memory::dereference_less</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structeos_1_1portable__oarchive_1_1dummy.html">eos::portable_oarchive::dummy&lt; int &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structeos_1_1portable__iarchive_1_1dummy.html">eos::portable_iarchive::dummy&lt; int &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1exception.html">qx::exception</a></td><td class="indexvalue">Qx::exception : exception with error code and error description </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1memory_1_1fast__mutex.html">qx::memory::fast_mutex</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1memory_1_1fast__mutex__autolock.html">qx::memory::fast_mutex_autolock</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1memory_1_1fixed__mem__pool.html">qx::memory::fixed_mem_pool&lt; _Tp &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container.html">qx::trait::generic_container&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::generic_container&lt;T&gt; : provide some tools to manage all containers without knowing its type </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01boost_1_1unordered__map_3_01_key_00_01_value_01_4_01_4.html">qx::trait::generic_container&lt; boost::unordered_map&lt; Key, Value &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01boost_1_1unordered__multimap_3_01_key_00_01_value_01_4_01_4.html">qx::trait::generic_container&lt; boost::unordered_multimap&lt; Key, Value &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01boost_1_1unordered__multiset_3_01_t_01_4_01_4.html">qx::trait::generic_container&lt; boost::unordered_multiset&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01boost_1_1unordered__set_3_01_t_01_4_01_4.html">qx::trait::generic_container&lt; boost::unordered_set&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01_q_hash_3_01_key_00_01_value_01_4_01_4.html">qx::trait::generic_container&lt; QHash&lt; Key, Value &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01_q_linked_list_3_01_t_01_4_01_4.html">qx::trait::generic_container&lt; QLinkedList&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01_q_list_3_01_t_01_4_01_4.html">qx::trait::generic_container&lt; QList&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01_q_map_3_01_key_00_01_value_01_4_01_4.html">qx::trait::generic_container&lt; QMap&lt; Key, Value &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01_q_multi_hash_3_01_key_00_01_value_01_4_01_4.html">qx::trait::generic_container&lt; QMultiHash&lt; Key, Value &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01_q_multi_map_3_01_key_00_01_value_01_4_01_4.html">qx::trait::generic_container&lt; QMultiMap&lt; Key, Value &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01_q_set_3_01_t_01_4_01_4.html">qx::trait::generic_container&lt; QSet&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01_q_vector_3_01_t_01_4_01_4.html">qx::trait::generic_container&lt; QVector&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01qx_1_1_qx_collection_3_01_key_00_01_value_01_4_01_4.html">qx::trait::generic_container&lt; qx::QxCollection&lt; Key, Value &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01std_1_1list_3_01_t_01_4_01_4.html">qx::trait::generic_container&lt; std::list&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01std_1_1map_3_01_key_00_01_value_01_4_01_4.html">qx::trait::generic_container&lt; std::map&lt; Key, Value &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01std_1_1set_3_01_t_01_4_01_4.html">qx::trait::generic_container&lt; std::set&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container_3_01std_1_1vector_3_01_t_01_4_01_4.html">qx::trait::generic_container&lt; std::vector&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1generic__container__base.html">qx::trait::detail::generic_container_base&lt; Container, Item &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1generic__container__base__key__value__qt__style.html">qx::trait::detail::generic_container_base_key_value_qt_style&lt; Container, Key, Value &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1generic__container__base__key__value__std__style.html">qx::trait::detail::generic_container_base_key_value_std_style&lt; Container, Key, Value &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1generic__container__base__set.html">qx::trait::detail::generic_container_base_set&lt; Container, Item &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1generic__container__base__without__reserve.html">qx::trait::detail::generic_container_base_without_reserve&lt; Container, Item &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container__item.html">qx::trait::generic_container_item&lt; Key, Value &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1get__base__class.html">qx::trait::get_base_class&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::get_base_class&lt;T&gt;::type : retrieve base class of type T registered into QxOrm context and return <a class="el" href="classqx_1_1trait_1_1no__base__class__defined.html">qx::trait::no_base_class_defined</a> if no base class defined </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1get__base__class__2.html">qx::trait::get_base_class_2&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__class__name.html">qx::trait::get_class_name&lt; T &gt;</a></td><td class="indexvalue"><a class="el" href="group___qx_cache.html#gaf467221c40ed6d8960109a8a00c3e3fa" title="Return the object of type T associated with key sKey, or return default instance of T() if the key do...">Qx::trait::get_class_name&lt;T&gt;::get()</a> : return class name of type T under const char * format, T must be registered with <a class="el" href="get__class__name_8h.html#a6face32a54f802912681b1c81d2263e6">QX_REGISTER_CLASS_NAME(T)</a> macro </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1get__primary__key.html">qx::trait::get_primary_key&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::get_primary_key&lt;T&gt;::type : return primary key type of T, by default primary key is long type, use <a class="el" href="get__primary__key_8h.html#af93e7d48eb234463102562f07c9aeb7b">QX_REGISTER_PRIMARY_KEY()</a> macro to register another type (for example <a class="el" href="get__primary__key_8h.html#af93e7d48eb234463102562f07c9aeb7b">QX_REGISTER_PRIMARY_KEY(T, QString)</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1get__sql__type.html">qx::trait::detail::get_sql_type&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type.html">qx::trait::get_sql_type&lt; T &gt;</a></td><td class="indexvalue"><a class="el" href="group___qx_cache.html#gaf467221c40ed6d8960109a8a00c3e3fa" title="Return the object of type T associated with key sKey, or return default instance of T() if the key do...">Qx::trait::get_sql_type&lt;T&gt;::get()</a> : return type name under const char * format used by database engine to map a C++ type T </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01boost_1_1intrusive__ptr_3_01_t_01_4_01_4.html">qx::trait::get_sql_type&lt; boost::intrusive_ptr&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01boost_1_1optional_3_01_t_01_4_01_4.html">qx::trait::get_sql_type&lt; boost::optional&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01boost_1_1scoped__ptr_3_01_t_01_4_01_4.html">qx::trait::get_sql_type&lt; boost::scoped_ptr&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01boost_1_1shared__ptr_3_01_t_01_4_01_4.html">qx::trait::get_sql_type&lt; boost::shared_ptr&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01boost_1_1tuple_3_01_t1_00_01_t2_01_4_01_4.html">qx::trait::get_sql_type&lt; boost::tuple&lt; T1, T2 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01boost_1_1tuple_3_01_t1_00_01_t2_00_01_t3_01_4_01_4.html">qx::trait::get_sql_type&lt; boost::tuple&lt; T1, T2, T3 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01boost_1_1tuple_3_01_t1_00_01_t2_00_01_t3_00_01_t4_01_4_01_4.html">qx::trait::get_sql_type&lt; boost::tuple&lt; T1, T2, T3, T4 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01boost_1_1tuple_3_01_t1_00_01_t2_00_01_t3_00_01_t4_00_01_t5_01_4_01_4.html">qx::trait::get_sql_type&lt; boost::tuple&lt; T1, T2, T3, T4, T5 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01boost_1_1tuple_3_01_t1_00_01_t2_00_01_t3_00_01_t4_00_01_t5_00_01_t6_01_4_01_4.html">qx::trait::get_sql_type&lt; boost::tuple&lt; T1, T2, T3, T4, T5, T6 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01boost_1_1tuple_3_01_t1_00_01_t2_00_01_t3_00_01_t4_00_01_t5_00_01_t6_00_01_t7_01_4_01_4.html">qx::trait::get_sql_type&lt; boost::tuple&lt; T1, T2, T3, T4, T5, T6, T7 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01boost_1_1tuple_3_01_t1_00_01_t2_00_01_t3_00_01_t4_00_01_7aa6b8576f69e7ff5903c6ac8473130a.html">qx::trait::get_sql_type&lt; boost::tuple&lt; T1, T2, T3, T4, T5, T6, T7, T8 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01boost_1_1tuple_3_01_t1_00_01_t2_00_01_t3_00_01_t4_00_01_af3507f22302466a1492c46749f53bff.html">qx::trait::get_sql_type&lt; boost::tuple&lt; T1, T2, T3, T4, T5, T6, T7, T8, T9 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01_q_pair_3_01_t1_00_01_t2_01_4_01_4.html">qx::trait::get_sql_type&lt; QPair&lt; T1, T2 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01_q_shared_pointer_3_01_t_01_4_01_4.html">qx::trait::get_sql_type&lt; QSharedPointer&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01qx_1_1dao_1_1ptr_3_01_t_01_4_01_4.html">qx::trait::get_sql_type&lt; qx::dao::ptr&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1get__sql__type_3_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.html">qx::trait::get_sql_type&lt; std::pair&lt; T1, T2 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1get__sql__type__helper.html">qx::trait::detail::get_sql_type_helper&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_sql_relation_1_1get_container___helper.html">qx::QxSqlRelation&lt; DataType, Owner &gt;::getContainer_Helper&lt; bIsPointer, bIsContainer, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_sql_relation_1_1get_container___helper_3_01false_00_01true_00_01dummy_01_4.html">qx::QxSqlRelation&lt; DataType, Owner &gt;::getContainer_Helper&lt; false, true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_sql_relation_1_1get_container___helper_3_01true_00_01false_00_01dummy_01_4.html">qx::QxSqlRelation&lt; DataType, Owner &gt;::getContainer_Helper&lt; true, false, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_sql_relation_1_1get_container___helper_3_01true_00_01true_00_01dummy_01_4.html">qx::QxSqlRelation&lt; DataType, Owner &gt;::getContainer_Helper&lt; true, true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_sql_relation_1_1get_data___helper.html">qx::QxSqlRelation&lt; DataType, Owner &gt;::getData_Helper&lt; bIsPointer, bIsContainer, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_sql_relation_1_1get_data___helper_3_01false_00_01true_00_01dummy_01_4.html">qx::QxSqlRelation&lt; DataType, Owner &gt;::getData_Helper&lt; false, true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_sql_relation_1_1get_data___helper_3_01true_00_01false_00_01dummy_01_4.html">qx::QxSqlRelation&lt; DataType, Owner &gt;::getData_Helper&lt; true, false, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_sql_relation_1_1get_data___helper_3_01true_00_01true_00_01dummy_01_4.html">qx::QxSqlRelation&lt; DataType, Owner &gt;::getData_Helper&lt; true, true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1has__operator__equal__equal.html">qx::trait::has_operator_equal_equal&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::has_operator_equal_equal&lt;T&gt;::value : return true if T provides <a class="el" href="_qx_dao_pointer_8h.html#a0af5e0c52a475d38f54b777961a1a4a5">operator==()</a> function, T must be registered with <a class="el" href="is__equal_8h.html#a3ee3bc97ffc58077407d8236b918e49d">QX_TYPE_HAS_OPERATOR_EQUAL_EQUAL(T)</a> macro </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_class_1_1implement_ix_persistable___helper.html">qx::QxClass&lt; T &gt;::implementIxPersistable_Helper&lt; U, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_class_1_1implement_ix_persistable___helper_3_01_q_object_00_01dummy_01_4.html">qx::QxClass&lt; T &gt;::implementIxPersistable_Helper&lt; QObject, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_class_1_1implement_ix_persistable___helper_3_01qx_1_1trait_1_1no__base__class__defined_00_01dummy_01_4.html">qx::QxClass&lt; T &gt;::implementIxPersistable_Helper&lt; qx::trait::no_base_class_defined, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_class_x_1_1invoke__default.html">qx::QxClassX::invoke_default&lt; U &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_class_x_1_1invoke__ptr.html">qx::QxClassX::invoke_ptr&lt; U &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__printable.html">qx::trait::is_archive_printable&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_archive_printable&lt;T&gt;::value : define if a <a class="el" href="namespaceboost_1_1archive.html">boost::archive</a> type is readable by a human (for example XML archive) or not (for example binary archive) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__printable_3_01boost_1_1archive_1_1polymorphic__iarchive_01_4.html">qx::trait::is_archive_printable&lt; boost::archive::polymorphic_iarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__printable_3_01boost_1_1archive_1_1polymorphic__oarchive_01_4.html">qx::trait::is_archive_printable&lt; boost::archive::polymorphic_oarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__printable_3_01boost_1_1archive_1_1text__iarchive_01_4.html">qx::trait::is_archive_printable&lt; boost::archive::text_iarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__printable_3_01boost_1_1archive_1_1text__oarchive_01_4.html">qx::trait::is_archive_printable&lt; boost::archive::text_oarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__printable_3_01boost_1_1archive_1_1text__wiarchive_01_4.html">qx::trait::is_archive_printable&lt; boost::archive::text_wiarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__printable_3_01boost_1_1archive_1_1text__woarchive_01_4.html">qx::trait::is_archive_printable&lt; boost::archive::text_woarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__printable_3_01boost_1_1archive_1_1xml__iarchive_01_4.html">qx::trait::is_archive_printable&lt; boost::archive::xml_iarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__printable_3_01boost_1_1archive_1_1xml__oarchive_01_4.html">qx::trait::is_archive_printable&lt; boost::archive::xml_oarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__printable_3_01boost_1_1archive_1_1xml__wiarchive_01_4.html">qx::trait::is_archive_printable&lt; boost::archive::xml_wiarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__printable_3_01boost_1_1archive_1_1xml__woarchive_01_4.html">qx::trait::is_archive_printable&lt; boost::archive::xml_woarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__wide.html">qx::trait::is_archive_wide&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_archive_wide&lt;T&gt;::value : define if a <a class="el" href="namespaceboost_1_1archive.html">boost::archive</a> type uses wide string character and stream (for example std::wstring) or not (for example std::string) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__wide_3_01boost_1_1archive_1_1binary__wiarchive_01_4.html">qx::trait::is_archive_wide&lt; boost::archive::binary_wiarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__wide_3_01boost_1_1archive_1_1binary__woarchive_01_4.html">qx::trait::is_archive_wide&lt; boost::archive::binary_woarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__wide_3_01boost_1_1archive_1_1text__wiarchive_01_4.html">qx::trait::is_archive_wide&lt; boost::archive::text_wiarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__wide_3_01boost_1_1archive_1_1text__woarchive_01_4.html">qx::trait::is_archive_wide&lt; boost::archive::text_woarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__wide_3_01boost_1_1archive_1_1xml__wiarchive_01_4.html">qx::trait::is_archive_wide&lt; boost::archive::xml_wiarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__archive__wide_3_01boost_1_1archive_1_1xml__woarchive_01_4.html">qx::trait::is_archive_wide&lt; boost::archive::xml_woarchive &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__base__class__defined.html">qx::trait::is_base_class_defined&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__boost__intrusive__ptr.html">qx::trait::is_boost_intrusive_ptr&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_boost_intrusive_ptr&lt;T&gt;::value : return true if T is a boost::intrusive_ptr&lt;&gt; smart-pointer, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__boost__scoped__ptr.html">qx::trait::is_boost_scoped_ptr&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_boost_scoped_ptr&lt;T&gt;::value : return true if T is a boost::scoped_ptr&lt;&gt; smart-pointer, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__boost__shared__ptr.html">qx::trait::is_boost_shared_ptr&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_boost_shared_ptr&lt;T&gt;::value : return true if T is a boost::shared_ptr&lt;&gt; smart-pointer, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__boost__unordered__map.html">qx::trait::is_boost_unordered_map&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_boost_unordered_map&lt;T&gt;::value : return true if T is a boost::unordered_map&lt;&gt; or boost::unordered_multimap&lt;&gt; container, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__boost__unordered__set.html">qx::trait::is_boost_unordered_set&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_boost_unordered_set&lt;T&gt;::value : return true if T is a boost::unordered_set&lt;&gt; or boost::unordered_multiset&lt;&gt; container, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__boost__weak__ptr.html">qx::trait::is_boost_weak_ptr&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_boost_weak_ptr&lt;T&gt;::value : return true if T is a boost::weak_ptr&lt;&gt; smart-pointer, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__container.html">qx::trait::is_container&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_container&lt;T&gt;::value : return true if T is a container from stl, boost, Qt or QxOrm library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__container__base__of.html">qx::trait::is_container_base_of&lt; B, D &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__container__key__value.html">qx::trait::is_container_key_value&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_container_key_value&lt;T&gt;::value : return true if T is a map or hash-map (with &lt;Key, Value&gt; template format) container from stl, boost, Qt or QxOrm library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__container__to__pod.html">qx::trait::is_container_to_pod&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__ix__persistable.html">qx::trait::is_ix_persistable&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_ix_persistable&lt;T&gt;::value : return true if T implements <a class="el" href="classqx_1_1_ix_persistable.html" title="qx::IxPersistable : common interface (abstract class) for persistents classes using QX_PERSISTABLE_HP...">qx::IxPersistable</a> interface, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__ptr__base__of.html">qx::trait::is_ptr_base_of&lt; B, D &gt;</a></td><td class="indexvalue">Qx::trait::is_ptr_base_of&lt;B, D&gt;::value : return true if B and D are pointer type and (*B) is a base class of (*D) or if B and D are same type, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__ptr__to__pod.html">qx::trait::is_ptr_to_pod&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_ptr_to_pod&lt;T&gt;::value : return true if T is a pointer to a POD type (char, int, long, etc.), otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__qt__hash.html">qx::trait::is_qt_hash&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qt_hash&lt;T&gt;::value : return true if T is a QHash&lt;&gt; container of Qt library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__qt__linked__list.html">qx::trait::is_qt_linked_list&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qt_linked_list&lt;T&gt;::value : return true if T is a QLinkedList&lt;&gt; container of Qt library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__qt__list.html">qx::trait::is_qt_list&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qt_list&lt;T&gt;::value : return true if T is a QList&lt;&gt; container of Qt library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__qt__map.html">qx::trait::is_qt_map&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qt_map&lt;T&gt;::value : return true if T is a QMap&lt;&gt; container of Qt library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__qt__multi__hash.html">qx::trait::is_qt_multi_hash&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qt_multi_hash&lt;T&gt;::value : return true if T is a QMultiHash&lt;&gt; container of Qt library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__qt__multi__map.html">qx::trait::is_qt_multi_map&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qt_multi_map&lt;T&gt;::value : return true if T is a QMultiMap&lt;&gt; container of Qt library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__qt__scoped__ptr.html">qx::trait::is_qt_scoped_ptr&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__qt__set.html">qx::trait::is_qt_set&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qt_set&lt;T&gt;::value : return true if T is a QSet&lt;&gt; container of Qt library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__qt__shared__data__ptr.html">qx::trait::is_qt_shared_data_ptr&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qt_shared_data_ptr&lt;T&gt;::value : return true if T is a QSharedDataPointer&lt;&gt; smart-pointer of Qt library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__qt__shared__ptr.html">qx::trait::is_qt_shared_ptr&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qt_shared_ptr&lt;T&gt;::value : return true if T is a QSharedPointer&lt;&gt; smart-pointer of Qt library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible.html">qx::trait::is_qt_variant_compatible&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qt_variant_compatible&lt;T&gt;::value : return true if T can be host into a QVariant object of Qt library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01bool_01_4.html">qx::trait::is_qt_variant_compatible&lt; bool &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01double_01_4.html">qx::trait::is_qt_variant_compatible&lt; double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01float_01_4.html">qx::trait::is_qt_variant_compatible&lt; float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01int_01_4.html">qx::trait::is_qt_variant_compatible&lt; int &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01long_01_4.html">qx::trait::is_qt_variant_compatible&lt; long &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01long_01double_01_4.html">qx::trait::is_qt_variant_compatible&lt; long double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01long_01long_01_4.html">qx::trait::is_qt_variant_compatible&lt; long long &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_bit_array_01_4.html">qx::trait::is_qt_variant_compatible&lt; QBitArray &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_byte_array_01_4.html">qx::trait::is_qt_variant_compatible&lt; QByteArray &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_char_01_4.html">qx::trait::is_qt_variant_compatible&lt; QChar &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_date_01_4.html">qx::trait::is_qt_variant_compatible&lt; QDate &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_date_time_01_4.html">qx::trait::is_qt_variant_compatible&lt; QDateTime &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_hash_3_01_q_string_00_01_q_variant_01_4_01_4.html">qx::trait::is_qt_variant_compatible&lt; QHash&lt; QString, QVariant &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_latin1_string_01_4.html">qx::trait::is_qt_variant_compatible&lt; QLatin1String &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_line_01_4.html">qx::trait::is_qt_variant_compatible&lt; QLine &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_line_f_01_4.html">qx::trait::is_qt_variant_compatible&lt; QLineF &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_list_3_01_q_variant_01_4_01_4.html">qx::trait::is_qt_variant_compatible&lt; QList&lt; QVariant &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_locale_01_4.html">qx::trait::is_qt_variant_compatible&lt; QLocale &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_map_3_01_q_string_00_01_q_variant_01_4_01_4.html">qx::trait::is_qt_variant_compatible&lt; QMap&lt; QString, QVariant &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_point_01_4.html">qx::trait::is_qt_variant_compatible&lt; QPoint &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_point_f_01_4.html">qx::trait::is_qt_variant_compatible&lt; QPointF &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_rect_01_4.html">qx::trait::is_qt_variant_compatible&lt; QRect &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_rect_f_01_4.html">qx::trait::is_qt_variant_compatible&lt; QRectF &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_reg_exp_01_4.html">qx::trait::is_qt_variant_compatible&lt; QRegExp &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_size_01_4.html">qx::trait::is_qt_variant_compatible&lt; QSize &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_size_f_01_4.html">qx::trait::is_qt_variant_compatible&lt; QSizeF &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_string_01_4.html">qx::trait::is_qt_variant_compatible&lt; QString &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_string_list_01_4.html">qx::trait::is_qt_variant_compatible&lt; QStringList &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_time_01_4.html">qx::trait::is_qt_variant_compatible&lt; QTime &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_url_01_4.html">qx::trait::is_qt_variant_compatible&lt; QUrl &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01_q_variant_01_4.html">qx::trait::is_qt_variant_compatible&lt; QVariant &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01short_01_4.html">qx::trait::is_qt_variant_compatible&lt; short &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01unsigned_01int_01_4.html">qx::trait::is_qt_variant_compatible&lt; unsigned int &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01unsigned_01long_01_4.html">qx::trait::is_qt_variant_compatible&lt; unsigned long &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01unsigned_01long_01long_01_4.html">qx::trait::is_qt_variant_compatible&lt; unsigned long long &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qt__variant__compatible_3_01unsigned_01short_01_4.html">qx::trait::is_qt_variant_compatible&lt; unsigned short &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__qt__vector.html">qx::trait::is_qt_vector&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qt_vector&lt;T&gt;::value : return true if T is a QVector&lt;&gt; container of Qt library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__qt__weak__ptr.html">qx::trait::is_qt_weak_ptr&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qt_weak_ptr&lt;T&gt;::value : return true if T is a QWeakPointer&lt;&gt; smart-pointer of Qt library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__qx__collection.html">qx::trait::is_qx_collection&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qx_collection&lt;T&gt;::value : return true if T is a qx::QxCollection&lt;&gt; container of QxOrm library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__qx__dao__ptr.html">qx::trait::is_qx_dao_ptr&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qx_dao_ptr&lt;T&gt;::value : return true if T is a qx::dao::ptr&lt;&gt; smart-pointer of QxOrm library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qx__pod.html">qx::trait::is_qx_pod&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qx_pod&lt;T&gt;::value : return true if T is a POD type and not a pointer </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1is__qx__registered.html">qx::trait::is_qx_registered&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_qx_registered&lt;T&gt;::value : return true if T is registered into QxOrm context to provide persitence (ORM), serialization and introspection features </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__smart__ptr.html">qx::trait::is_smart_ptr&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_smart_ptr&lt;T&gt;::value : return true if T is a smart-pointer of boost, Qt or QxOrm libraries, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__smart__ptr__base__of.html">qx::trait::is_smart_ptr_base_of&lt; B, D &gt;</a></td><td class="indexvalue">Qx::trait::is_smart_ptr_base_of&lt;B, D&gt;::value : return true if B and D are smart-pointers of boost, Qt or QxOrm libraries and if (*B) is a base class of (*D), otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__smart__ptr__to__pod.html">qx::trait::is_smart_ptr_to_pod&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_smart_ptr_to_pod&lt;T&gt;::value : return true if T is a smart-pointer of boost, Qt or QxOrm libraries and (*T) is a POD type (char, int, long, etc.), otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__std__list.html">qx::trait::is_std_list&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_std_list&lt;T&gt;::value : return true if T is a std::list&lt;&gt; container of stl library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__std__map.html">qx::trait::is_std_map&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_std_map&lt;T&gt;::value : return true if T is a std::map&lt;&gt; container of stl library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__std__set.html">qx::trait::is_std_set&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_std_set&lt;T&gt;::value : return true if T is a std::set&lt;&gt; container of stl library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1is__std__vector.html">qx::trait::is_std_vector&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_std_vector&lt;T&gt;::value : return true if T is a std::vector&lt;&gt; container of stl library, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1is__valid__primary__key.html">qx::trait::detail::is_valid_primary_key&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::is_valid_primary_key&lt;T&gt;(const T &amp; t) : return true if t can be a valid primary key to be inserted into a database, otherwise return false </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1is__valid__primary__key_3_01int_01_4.html">qx::trait::detail::is_valid_primary_key&lt; int &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1is__valid__primary__key_3_01long_01_4.html">qx::trait::detail::is_valid_primary_key&lt; long &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1is__valid__primary__key_3_01long_01long_01_4.html">qx::trait::detail::is_valid_primary_key&lt; long long &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1is__valid__primary__key_3_01_q_string_01_4.html">qx::trait::detail::is_valid_primary_key&lt; QString &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1is__valid__primary__key_3_01_q_variant_01_4.html">qx::trait::detail::is_valid_primary_key&lt; QVariant &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1is__valid__primary__key_3_01short_01_4.html">qx::trait::detail::is_valid_primary_key&lt; short &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1is__valid__primary__key_3_01std_1_1string_01_4.html">qx::trait::detail::is_valid_primary_key&lt; std::string &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1detail_1_1is__valid__primary__key_3_01std_1_1wstring_01_4.html">qx::trait::detail::is_valid_primary_key&lt; std::wstring &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_sql_relation_1_1is_null_data___helper.html">qx::QxSqlRelation&lt; DataType, Owner &gt;::isNullData_Helper&lt; bIsPointer, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_sql_relation_1_1is_null_data___helper_3_01true_00_01dummy_01_4.html">qx::QxSqlRelation&lt; DataType, Owner &gt;::isNullData_Helper&lt; true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_boost_serialize_register_helper.html">qx::IxBoostSerializeRegisterHelper</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_class.html">qx::IxClass</a></td><td class="indexvalue">Qx::IxClass : common interface for all classes registered into QxOrm context </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_collection.html">qx::IxCollection</a></td><td class="indexvalue">Qx::IxCollection : common interface for all QxOrm containers qx::QxCollection&lt;Key, Value&gt; </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_dao___helper.html">qx::dao::detail::IxDao_Helper</a></td><td class="indexvalue">Qx::dao::detail::IxDao_Helper : helper class to communicate with database </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_data_member.html">qx::IxDataMember</a></td><td class="indexvalue">Qx::IxDataMember : common interface for all class properties registered into QxOrm context </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_data_member_x.html">qx::IxDataMemberX</a></td><td class="indexvalue">Qx::IxDataMemberX : common interface for a list of <a class="el" href="classqx_1_1_ix_data_member.html" title="qx::IxDataMember : common interface for all class properties registered into QxOrm context...">IxDataMember</a> class properties registered into QxOrm context (for example, list of data member of a class) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_factory.html">qx::IxFactory</a></td><td class="indexvalue">Qx::IxFactory : common interface for all classes that can be created dynamically using the class name </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_function.html">qx::IxFunction</a></td><td class="indexvalue">Qx::IxFunction : common interface for all functions registered into QxOrm context (used by introspection engine) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1service_1_1_ix_parameter.html">qx::service::IxParameter</a></td><td class="indexvalue">Qx::service::IxParameter : common interface for all parameters transfered by <a class="el" href="classqx_1_1service_1_1_qx_service.html" title="qx::service::QxService&lt;INPUT, OUTPUT&gt; : concrete service class with INPUT parameters and OUTPUT param...">QxService</a> module of QxOrm library </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_persistable.html">qx::IxPersistable</a></td><td class="indexvalue">Qx::IxPersistable : common interface (abstract class) for persistents classes using <a class="el" href="_ix_persistable_8h.html#a311d8fc0e6c4fc1c42e43a54f2dc44da">QX_PERSISTABLE_HPP()</a> and <a class="el" href="_ix_persistable_8h.html#a8c17d818d8f1dbf25636a9d0ed2f96bd">QX_PERSISTABLE_CPP()</a> macros </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_persistable_collection.html">qx::IxPersistableCollection&lt; T &gt;</a></td><td class="indexvalue">Qx::IxPersistableCollection&lt;T&gt;::type : return the collection type used by <a class="el" href="classqx_1_1_ix_persistable.html" title="qx::IxPersistable : common interface (abstract class) for persistents classes using QX_PERSISTABLE_HP...">qx::IxPersistable</a> interface, <a class="el" href="classqx_1_1_qx_collection.html" title="qx::QxCollection&lt;Key, Value&gt; : QxOrm container (keep insertion order + quick access by index + quick ...">qx::QxCollection</a>&lt;type_primary_key, boost::shared_ptr&lt;my_type&gt;&gt; </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_repository.html">qx::IxRepository</a></td><td class="indexvalue">Qx::IxRepository : common interface for all repositories to provide access to database by introspection using QObject class or <a class="el" href="classqx_1_1_ix_collection.html" title="qx::IxCollection : common interface for all QxOrm containers qx::QxCollection&lt;Key, Value&gt;">qx::IxCollection</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1service_1_1_ix_service.html">qx::service::IxService</a></td><td class="indexvalue">Qx::service::IxService : common interface for all services defined with <a class="el" href="classqx_1_1service_1_1_qx_service.html" title="qx::service::QxService&lt;INPUT, OUTPUT&gt; : concrete service class with INPUT parameters and OUTPUT param...">QxService</a> module of QxOrm library </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_singleton.html">qx::IxSingleton</a></td><td class="indexvalue">Qx::IxSingleton : common interface for all singleton of QxOrm library </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_sql_element.html">qx::dao::detail::IxSqlElement</a></td><td class="indexvalue">Qx::dao::detail::IxSqlElement : common interface for all SQL elements to build SQL query </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_ix_sql_generator.html">qx::dao::detail::IxSqlGenerator</a></td><td class="indexvalue">Qx::dao::detail::IxSqlGenerator : common interface for all SQL generators to build SQL query specific for each database </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_sql_query_builder.html">qx::IxSqlQueryBuilder</a></td><td class="indexvalue">Qx::IxSqlQueryBuilder : common interface to build SQL queries to communicate with database </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_sql_relation.html">qx::IxSqlRelation</a></td><td class="indexvalue">Qx::IxSqlRelation : common interface for all relationships defined between 2 classes (or between 2 tables in database) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_type_info.html">qx::IxTypeInfo</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_validator.html">qx::IxValidator</a></td><td class="indexvalue">Qx::IxValidator : common interface for validator engine </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_ix_validator_x.html">qx::IxValidatorX</a></td><td class="indexvalue">Qx::IxValidatorX : common interface for a list of validators </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1serialization_1_1detail_1_1loader.html">qx::serialization::detail::loader&lt; Archive, T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1memory_1_1class__level__lock_1_1lock.html">qx::memory::class_level_lock&lt; _Host, _RealLock &gt;::lock</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1memory_1_1object__level__lock_1_1lock.html">qx::memory::object_level_lock&lt; _Host &gt;::lock</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1memory_1_1mem__pool__base.html">qx::memory::mem_pool_base</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container__item_1_1new___helper.html">qx::trait::generic_container_item&lt; Key, Value &gt;::new_Helper&lt; bIsPointer, T, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container__item_1_1new___helper_3_01false_00_01_t_00_01dummy_01_4.html">qx::trait::generic_container_item&lt; Key, Value &gt;::new_Helper&lt; false, T, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1construct__ptr_1_1new__ptr.html">qx::trait::construct_ptr&lt; T &gt;::new_ptr&lt; isAbstract, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1construct__ptr_1_1new__ptr_3_01true_00_01dummy_01_4.html">qx::trait::construct_ptr&lt; T &gt;::new_ptr&lt; true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1no__base__class__defined.html">qx::trait::no_base_class_defined</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1no__type.html">qx::trait::no_type</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1memory_1_1object__level__lock.html">qx::memory::object_level_lock&lt; _Host &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1memory_1_1output__object.html">qx::memory::output_object&lt; _OutputStrm, _StringType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classeos_1_1portable__archive__exception.html">eos::portable_archive_exception</a></td><td class="indexvalue">Exception being thrown when serialization cannot proceed </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeos_1_1portable__iarchive.html">eos::portable_iarchive</a></td><td class="indexvalue">Portable binary input archive using little endian format </td></tr>
  <tr><td class="indexkey"><a class="el" href="classeos_1_1portable__oarchive.html">eos::portable_oarchive</a></td><td class="indexvalue">Portable binary output archive using little endian format </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1ptr.html">qx::dao::ptr&lt; T &gt;</a></td><td class="indexvalue">Qx::dao::ptr&lt;T&gt; : provide a classic smart-pointer (like boost::shared_ptr&lt;T&gt; or QSharedPointer&lt;T&gt;) with some features associated with QxDao module of QxOrm library </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1qt__meta__object.html">qx::trait::qt_meta_object&lt; T &gt;</a></td><td class="indexvalue"><a class="el" href="group___qx_cache.html#gaf467221c40ed6d8960109a8a00c3e3fa" title="Return the object of type T associated with key sKey, or return default instance of T() if the key do...">Qx::trait::qt_meta_object&lt;T&gt;::get()</a> : if T is based on QObject class, then return QMetaObject instance of Qt introspection engine, else return NULL </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1qt__meta__object_1_1qt_meta_object.html">qx::trait::qt_meta_object&lt; T &gt;::qtMetaObject&lt; isQObject, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1qt__meta__object_1_1qt_meta_object_3_01true_00_01dummy_01_4.html">qx::trait::qt_meta_object&lt; T &gt;::qtMetaObject&lt; true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1foreach_1_1qx__deref.html">qx::foreach::qx_deref</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1foreach_1_1qx__deref__boost__or__qx.html">qx::foreach::qx_deref_boost_or_qx&lt; T, C, is_qx_collection &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1foreach_1_1qx__deref__boost__or__qx_3_01_t_00_01_c_00_01true_01_4.html">qx::foreach::qx_deref_boost_or_qx&lt; T, C, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1foreach_1_1qx__deref__deduce.html">qx::foreach::qx_deref_deduce&lt; T, C, is_qx_collection &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1foreach_1_1qx__deref__deduce_3_01_t_00_01_c_00_01true_01_4.html">qx::foreach::qx_deref_deduce&lt; T, C, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_archive.html">qx::QxArchive&lt; T, ArchiveInput, ArchiveOutput &gt;</a></td><td class="indexvalue">Qx::QxArchive : provide some tools to serialize a class registered into QxOrm context into/from binary/text/XML archives (file, string, etc.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_bool.html">qx::QxBool</a></td><td class="indexvalue">Qx_bool : boolean type with code and description message when an error occured </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_boost_init_guid.html">qx::QxBoostInitGuid&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_boost_serialize_helper.html">qx::QxBoostSerializeHelper&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_boost_serialize_register_helper.html">qx::QxBoostSerializeRegisterHelper&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_boost_serialize_register_helper_x.html">qx::QxBoostSerializeRegisterHelperX</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_boost_serialize_helper_1_1_qx_boost_void_cast_register_helper.html">qx::QxBoostSerializeHelper&lt; T &gt;::QxBoostVoidCastRegisterHelper&lt; bNoBaseClass, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_boost_serialize_helper_1_1_qx_boost_void_cast_register_helper_3_01true_00_01dummy_01_4.html">qx::QxBoostSerializeHelper&lt; T &gt;::QxBoostVoidCastRegisterHelper&lt; true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1cache_1_1detail_1_1_qx_cache.html">qx::cache::detail::QxCache</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_ix_data_member_1_1qx_cannot_access_data_pointer.html">qx::IxDataMember::qxCannotAccessDataPointer&lt; T, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_ix_data_member_1_1qx_cannot_access_data_pointer_3_01_q_string_00_01dummy_01_4.html">qx::IxDataMember::qxCannotAccessDataPointer&lt; QString, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_ix_data_member_1_1qx_cannot_access_data_pointer_3_01_q_variant_00_01dummy_01_4.html">qx::IxDataMember::qxCannotAccessDataPointer&lt; QVariant, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_class.html">qx::QxClass&lt; T &gt;</a></td><td class="indexvalue">Qx::QxClass&lt;T&gt; : concrete class of type T registered into QxOrm context (this class is a singleton and is thread-safe) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_class_name.html">qx::QxClassName&lt; T &gt;</a></td><td class="indexvalue">Qx::QxClassName&lt;T&gt; : class helper to retrieve the class name of type T under const char * format </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_class_x.html">qx::QxClassX</a></td><td class="indexvalue">Qx::QxClassX : list of all classes registered into QxOrm context (this container is a singleton) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1service_1_1_qx_client_async.html">qx::service::QxClientAsync</a></td><td class="indexvalue">Qx::service::QxClientAsync : class helper to easily execute an asynchronous transaction using a multi-thread process </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_collection.html">qx::QxCollection&lt; Key, Value &gt;</a></td><td class="indexvalue">Qx::QxCollection&lt;Key, Value&gt; : QxOrm container (keep insertion order + quick access by index + quick access by key) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_collection_iterator.html">qx::QxCollectionIterator&lt; Key, Value &gt;</a></td><td class="indexvalue">Qx::QxCollectionIterator : Java-style iterator to iterate over a qx::QxCollection&lt;Key, Value&gt; container </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_data_member_1_1qx_compare_data_member.html">qx::QxDataMember&lt; DataType, Owner &gt;::qxCompareDataMember&lt; bCanCompare, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_data_member_1_1qx_compare_data_member_3_01true_00_01dummy_01_4.html">qx::QxDataMember&lt; DataType, Owner &gt;::qxCompareDataMember&lt; true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1service_1_1_qx_connect.html">qx::service::QxConnect</a></td><td class="indexvalue">Qx::service::QxConnect : define connection parameters used by <a class="el" href="classqx_1_1service_1_1_qx_service.html" title="qx::service::QxService&lt;INPUT, OUTPUT&gt; : concrete service class with INPUT parameters and OUTPUT param...">QxService</a> module of QxOrm library (this class is a singleton) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_factory_1_1qx_create_instance.html">qx::QxFactory&lt; T &gt;::qxCreateInstance&lt; bIsAbstract, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_factory_1_1qx_create_instance_3_01true_00_01dummy_01_4.html">qx::QxFactory&lt; T &gt;::qxCreateInstance&lt; true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1dao_1_1detail_1_1_qx_dao___is_dirty.html">qx::dao::detail::QxDao_IsDirty&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1dao_1_1detail_1_1_qx_dao___is_dirty___container.html">qx::dao::detail::QxDao_IsDirty_Container&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1dao_1_1detail_1_1_qx_dao___is_dirty___generic.html">qx::dao::detail::QxDao_IsDirty_Generic&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1dao_1_1detail_1_1_qx_dao___is_dirty___ptr.html">qx::dao::detail::QxDao_IsDirty_Ptr&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_dao_async.html">qx::QxDaoAsync</a></td><td class="indexvalue">Qx::QxDaoAsync : helper class to execute SQL queries in another thread (asynchronous way) using <a class="el" href="classqx_1_1_ix_persistable.html" title="qx::IxPersistable : common interface (abstract class) for persistents classes using QX_PERSISTABLE_HP...">qx::IxPersistable</a> interface </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1dao_1_1detail_1_1_qx_dao_async_params.html">qx::dao::detail::QxDaoAsyncParams</a></td><td class="indexvalue">Qx::dao::detail::QxDaoAsyncParams : all parameters for <a class="el" href="classqx_1_1_qx_dao_async.html" title="qx::QxDaoAsync : helper class to execute SQL queries in another thread (asynchronous way) using qx::I...">qx::QxDaoAsync</a> class to execute queries </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_dao_async_runner.html">qx::dao::detail::QxDaoAsyncRunner</a></td><td class="indexvalue">Qx::dao::detail::QxDaoAsyncRunner : class with a slot to execute queries in another thread </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_data_member.html">qx::QxDataMember&lt; DataType, Owner &gt;</a></td><td class="indexvalue">Qx::QxDataMember&lt;DataType, Owner&gt; : concrete property of type DataType registered into QxOrm context for the class Owner </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_data_member___q_object.html">qx::QxDataMember_QObject</a></td><td class="indexvalue">Qx::QxDataMember_QObject : connect Qt introspection engine (based on QObject class, with QMetaObject type) to QxOrm library introspection engine </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_data_member_x.html">qx::QxDataMemberX&lt; T &gt;</a></td><td class="indexvalue">Qx::QxDataMemberX&lt;T&gt; : concrete list of properties registered into QxOrm context for the class T </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_date_neutral.html">qx::QxDateNeutral</a></td><td class="indexvalue">Qx::QxDateNeutral : helper class to store a date value into database under neutral format (YYYYMMDD) =&gt; cross database compatibility </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_date_time_neutral.html">qx::QxDateTimeNeutral</a></td><td class="indexvalue">Qx::QxDateTimeNeutral : helper class to store a date-time value into database under neutral format (YYYYMMDDHHMMSS) =&gt; cross database compatibility </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_factory.html">qx::QxFactory&lt; T &gt;</a></td><td class="indexvalue">Qx::QxFactory&lt;T&gt; : concrete factory class to create object of type T dynamically using the class name </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_factory_x.html">qx::QxFactoryX</a></td><td class="indexvalue">Qx::QxFactoryX : list of all classes registered with QxOrm library factory pattern to create object instance dynamically using the class name </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__0.html">qx::QxFunction_0&lt; Owner, R &gt;</a></td><td class="indexvalue">Qx::QxFunction_0&lt;Owner, R&gt; : concrete function registered into QxOrm context defined into class Owner, returning an object of type R and without parameter </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__0_3_01void_00_01_r_01_4.html">qx::QxFunction_0&lt; void, R &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__1.html">qx::QxFunction_1&lt; Owner, R, P1 &gt;</a></td><td class="indexvalue">Qx::QxFunction_1&lt;Owner, R, P1&gt; : concrete function registered into QxOrm context defined into class Owner, returning an object of type R and with 1 parameter P1 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__1_3_01void_00_01_r_00_01_p1_01_4.html">qx::QxFunction_1&lt; void, R, P1 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__2.html">qx::QxFunction_2&lt; Owner, R, P1, P2 &gt;</a></td><td class="indexvalue">Qx::QxFunction_2&lt;Owner, R, P1, P2&gt; : concrete function registered into QxOrm context defined into class Owner, returning an object of type R and with 2 parameters P1, P2 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__2_3_01void_00_01_r_00_01_p1_00_01_p2_01_4.html">qx::QxFunction_2&lt; void, R, P1, P2 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__3.html">qx::QxFunction_3&lt; Owner, R, P1, P2, P3 &gt;</a></td><td class="indexvalue">Qx::QxFunction_3&lt;Owner, R, P1, P2, P3&gt; : concrete function registered into QxOrm context defined into class Owner, returning an object of type R and with 3 parameters P1, P2, P3 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__3_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_01_4.html">qx::QxFunction_3&lt; void, R, P1, P2, P3 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__4.html">qx::QxFunction_4&lt; Owner, R, P1, P2, P3, P4 &gt;</a></td><td class="indexvalue">Qx::QxFunction_4&lt;Owner, R, P1, P2, P3, P4&gt; : concrete function registered into QxOrm context defined into class Owner, returning an object of type R and with 4 parameters P1, P2, P3, P4 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__4_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_01_4.html">qx::QxFunction_4&lt; void, R, P1, P2, P3, P4 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__5.html">qx::QxFunction_5&lt; Owner, R, P1, P2, P3, P4, P5 &gt;</a></td><td class="indexvalue">Qx::QxFunction_5&lt;Owner, R, P1, P2, P3, P4, P5&gt; : concrete function registered into QxOrm context defined into class Owner, returning an object of type R and with 5 parameters P1, P2, P3, P4, P5 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__5_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_01_4.html">qx::QxFunction_5&lt; void, R, P1, P2, P3, P4, P5 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__6.html">qx::QxFunction_6&lt; Owner, R, P1, P2, P3, P4, P5, P6 &gt;</a></td><td class="indexvalue">Qx::QxFunction_6&lt;Owner, R, P1, P2, P3, P4, P5, P6&gt; : concrete function registered into QxOrm context defined into class Owner, returning an object of type R and with 6 parameters P1, P2, P3, P4, P5, P6 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__6_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_00_01_p6_01_4.html">qx::QxFunction_6&lt; void, R, P1, P2, P3, P4, P5, P6 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__7.html">qx::QxFunction_7&lt; Owner, R, P1, P2, P3, P4, P5, P6, P7 &gt;</a></td><td class="indexvalue">Qx::QxFunction_7&lt;Owner, R, P1, P2, P3, P4, P5, P6, P7&gt; : concrete function registered into QxOrm context defined into class Owner, returning an object of type R and with 7 parameters P1, P2, P3, P4, P5, P6, P7 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__7_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_00_01_p6_00_01_p7_01_4.html">qx::QxFunction_7&lt; void, R, P1, P2, P3, P4, P5, P6, P7 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__8.html">qx::QxFunction_8&lt; Owner, R, P1, P2, P3, P4, P5, P6, P7, P8 &gt;</a></td><td class="indexvalue">Qx::QxFunction_8&lt;Owner, R, P1, P2, P3, P4, P5, P6, P7, P8&gt; : concrete function registered into QxOrm context defined into class Owner, returning an object of type R and with 8 parameters P1, P2, P3, P4, P5, P6, P7, P8 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__8_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_00_01_p6_00_01_p7_00_01_p8_01_4.html">qx::QxFunction_8&lt; void, R, P1, P2, P3, P4, P5, P6, P7, P8 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__9.html">qx::QxFunction_9&lt; Owner, R, P1, P2, P3, P4, P5, P6, P7, P8, P9 &gt;</a></td><td class="indexvalue">Qx::QxFunction_9&lt;Owner, R, P1, P2, P3, P4, P5, P6, P7, P8, P9&gt; : concrete function registered into QxOrm context defined into class Owner, returning an object of type R and with 9 parameters P1, P2, P3, P4, P5, P6, P7, P8, P9 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_function__9_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_00_01_pd88fc1889c5bafa557deb8bbe5009279.html">qx::QxFunction_9&lt; void, R, P1, P2, P3, P4, P5, P6, P7, P8, P9 &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_class_name_1_1qx_get_class_name.html">qx::QxClassName&lt; T &gt;::qxGetClassName&lt; bIsQxRegistered, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_class_name_1_1qx_get_class_name_3_01true_00_01dummy_01_4.html">qx::QxClassName&lt; T &gt;::qxGetClassName&lt; true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_invalid_value.html">qx::QxInvalidValue</a></td><td class="indexvalue">Qx::QxInvalidValue : invalid value when a property fails to pass a constraint </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_invalid_value_x.html">qx::QxInvalidValueX</a></td><td class="indexvalue">Qx::QxInvalidValueX : list of invalid values </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__2_3_01void_00_01_r_00_01_p1_00_01_p2_01_4_1_1_qx_invoker_fct.html">qx::QxFunction_2&lt; void, R, P1, P2 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__3_1_1_qx_invoker_fct.html">qx::QxFunction_3&lt; Owner, R, P1, P2, P3 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__4_1_1_qx_invoker_fct.html">qx::QxFunction_4&lt; Owner, R, P1, P2, P3, P4 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__4_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_01_4_1_1_qx_invoker_fct.html">qx::QxFunction_4&lt; void, R, P1, P2, P3, P4 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__5_1_1_qx_invoker_fct.html">qx::QxFunction_5&lt; Owner, R, P1, P2, P3, P4, P5 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__8_1_1_qx_invoker_fct.html">qx::QxFunction_8&lt; Owner, R, P1, P2, P3, P4, P5, P6, P7, P8 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__6_1_1_qx_invoker_fct.html">qx::QxFunction_6&lt; Owner, R, P1, P2, P3, P4, P5, P6 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__6_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_00_01_p6_01_4_1_1_qx_invoker_fct.html">qx::QxFunction_6&lt; void, R, P1, P2, P3, P4, P5, P6 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__7_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_00_01_dfa32854071e12a5ab12d5624ffab704.html">qx::QxFunction_7&lt; void, R, P1, P2, P3, P4, P5, P6, P7 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__8_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_00_01_cad905d6f10c38bc9d812206208c0b01.html">qx::QxFunction_8&lt; void, R, P1, P2, P3, P4, P5, P6, P7, P8 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__7_1_1_qx_invoker_fct.html">qx::QxFunction_7&lt; Owner, R, P1, P2, P3, P4, P5, P6, P7 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__0_1_1_qx_invoker_fct.html">qx::QxFunction_0&lt; Owner, R &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__5_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_01_4_1_1_qx_invoker_fct.html">qx::QxFunction_5&lt; void, R, P1, P2, P3, P4, P5 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__3_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_01_4_1_1_qx_invoker_fct.html">qx::QxFunction_3&lt; void, R, P1, P2, P3 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__2_1_1_qx_invoker_fct.html">qx::QxFunction_2&lt; Owner, R, P1, P2 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__1_3_01void_00_01_r_00_01_p1_01_4_1_1_qx_invoker_fct.html">qx::QxFunction_1&lt; void, R, P1 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__9_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_00_01_f77ff774156b19b08994e5640b714347.html">qx::QxFunction_9&lt; void, R, P1, P2, P3, P4, P5, P6, P7, P8, P9 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__0_3_01void_00_01_r_01_4_1_1_qx_invoker_fct.html">qx::QxFunction_0&lt; void, R &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__1_1_1_qx_invoker_fct.html">qx::QxFunction_1&lt; Owner, R, P1 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__9_1_1_qx_invoker_fct.html">qx::QxFunction_9&lt; Owner, R, P1, P2, P3, P4, P5, P6, P7, P8, P9 &gt;::QxInvokerFct&lt; T, bReturnValue &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__2_3_01void_00_01_r_00_01_p1_00_01_p2_01_4_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_2&lt; void, R, P1, P2 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__6_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_00_01_716cd2a79dfdc585d9b5dd876fe40159.html">qx::QxFunction_6&lt; void, R, P1, P2, P3, P4, P5, P6 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__1_3_01void_00_01_r_00_01_p1_01_4_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_1&lt; void, R, P1 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__3_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_3&lt; Owner, R, P1, P2, P3 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__4_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_4&lt; Owner, R, P1, P2, P3, P4 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__4_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_01_4_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_4&lt; void, R, P1, P2, P3, P4 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__0_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_0&lt; Owner, R &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__5_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_5&lt; Owner, R, P1, P2, P3, P4, P5 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__5_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_01_4_11fd17393394470ee3e32884a35d70d33.html">qx::QxFunction_5&lt; void, R, P1, P2, P3, P4, P5 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__6_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_6&lt; Owner, R, P1, P2, P3, P4, P5, P6 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__9_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_9&lt; Owner, R, P1, P2, P3, P4, P5, P6, P7, P8, P9 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__8_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_00_01_e6a7ca339803cfcd4cb361e27604e5c8.html">qx::QxFunction_8&lt; void, R, P1, P2, P3, P4, P5, P6, P7, P8 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__8_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_8&lt; Owner, R, P1, P2, P3, P4, P5, P6, P7, P8 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__7_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_00_01_8af9c5148ffa559d7b5a0d94128435d0.html">qx::QxFunction_7&lt; void, R, P1, P2, P3, P4, P5, P6, P7 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__3_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_01_4_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_3&lt; void, R, P1, P2, P3 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__0_3_01void_00_01_r_01_4_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_0&lt; void, R &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__2_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_2&lt; Owner, R, P1, P2 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__9_3_01void_00_01_r_00_01_p1_00_01_p2_00_01_p3_00_01_p4_00_01_p5_00_01_08f10169d2fc0bd5da0cd17a0fc111da.html">qx::QxFunction_9&lt; void, R, P1, P2, P3, P4, P5, P6, P7, P8, P9 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__1_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_1&lt; Owner, R, P1 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_function__7_1_1_qx_invoker_fct_3_01_t_00_01true_01_4.html">qx::QxFunction_7&lt; Owner, R, P1, P2, P3, P4, P5, P6, P7 &gt;::QxInvokerFct&lt; T, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_property_bag.html">qx::QxPropertyBag</a></td><td class="indexvalue">Qx::QxPropertyBag : used by introspection engine (<a class="el" href="classqx_1_1_ix_class.html" title="qx::IxClass : common interface for all classes registered into QxOrm context">IxClass</a>, <a class="el" href="classqx_1_1_ix_data_member.html" title="qx::IxDataMember : common interface for all class properties registered into QxOrm context...">IxDataMember</a>, <a class="el" href="classqx_1_1_ix_function.html" title="qx::IxFunction : common interface for all functions registered into QxOrm context (used by introspect...">IxFunction</a>, etc.) to add meta-data (property bag) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_repository.html">qx::QxRepository&lt; T &gt;</a></td><td class="indexvalue">Qx::QxRepository&lt;T&gt; : repository to provide a common interface to communicate with database </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_repository_x.html">qx::QxRepositoryX</a></td><td class="indexvalue">Qx::QxRepositoryX : list of all repositories registered using <a class="el" href="namespaceqx.html#a10d662c78d56271d8fdaeff896548e46">qx::register_repository&lt;T&gt;</a> function </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1service_1_1_qx_server.html">qx::service::QxServer</a></td><td class="indexvalue">Qx::service::QxServer : server side to manage a thread pool of incoming connections (new request from client) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1service_1_1_qx_service.html">qx::service::QxService&lt; INPUT, OUTPUT &gt;</a></td><td class="indexvalue">Qx::service::QxService&lt;INPUT, OUTPUT&gt; : concrete service class with INPUT parameters and OUTPUT parameters </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_session.html">qx::QxSession</a></td><td class="indexvalue">Qx::QxSession : define a session to manage automatically database transactions (using C++ RAII) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_simple_crypt.html">qx::QxSimpleCrypt</a></td><td class="indexvalue">Simple encryption and decryption of strings and byte arrays </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_singleton.html">qx::QxSingleton&lt; T &gt;</a></td><td class="indexvalue">Qx::QxSingleton&lt;T&gt; : concrete class to define a thread-safe singleton of type T </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_singleton_x.html">qx::QxSingletonX</a></td><td class="indexvalue">Qx::QxSingletonX : list of all singleton defined by QxOrm library (this container is also a singleton) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_soft_delete.html">qx::QxSoftDelete</a></td><td class="indexvalue">Qx::QxSoftDelete : soft delete (or logical delete) behavior to update a row into database (flag it as deleted) instead of delete it from database </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_compare.html">qx::dao::detail::QxSqlCompare</a></td><td class="indexvalue">Qx::dao::detail::QxSqlCompare : SQL element to compare value (==, &lt;, &gt;, &lt;=, &gt;=, LIKE, NOT LIKE, etc.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_sql_database.html">qx::QxSqlDatabase</a></td><td class="indexvalue">Qx::QxSqlDatabase : define all parameters to connect to database and retrieve a valid connection by thread (this class is a singleton and is thread-safe) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_element_temp.html">qx::dao::detail::QxSqlElementTemp</a></td><td class="indexvalue">Qx::dao::detail::QxSqlElementTemp : temporary SQL element (need to be cloned to be used) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_expression.html">qx::dao::detail::QxSqlExpression</a></td><td class="indexvalue">Qx::dao::detail::QxSqlExpression : SQL element to build a SQL expression (WHERE, AND, OR, etc.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_free_text.html">qx::dao::detail::QxSqlFreeText</a></td><td class="indexvalue">Qx::dao::detail::QxSqlFreeText : possibility to add free text to SQL query </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___m_s_s_q_l_server.html">qx::dao::detail::QxSqlGenerator_MSSQLServer</a></td><td class="indexvalue">Qx::dao::detail::QxSqlGenerator_MSSQLServer : SQL generator for Microsoft SQL Server database </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___my_s_q_l.html">qx::dao::detail::QxSqlGenerator_MySQL</a></td><td class="indexvalue">Qx::dao::detail::QxSqlGenerator_MySQL : SQL generator for MySQL database </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___oracle.html">qx::dao::detail::QxSqlGenerator_Oracle</a></td><td class="indexvalue">Qx::dao::detail::QxSqlGenerator_Oracle : SQL generator for Oracle database </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___postgre_s_q_l.html">qx::dao::detail::QxSqlGenerator_PostgreSQL</a></td><td class="indexvalue">Qx::dao::detail::QxSqlGenerator_PostgreSQL : SQL generator for PostgreSQL database </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___s_q_lite.html">qx::dao::detail::QxSqlGenerator_SQLite</a></td><td class="indexvalue">Qx::dao::detail::QxSqlGenerator_SQLite : SQL generator for SQLite database </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_generator___standard.html">qx::dao::detail::QxSqlGenerator_Standard</a></td><td class="indexvalue">Qx::dao::detail::QxSqlGenerator_Standard : SQL generator to build standard SQL query </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_in.html">qx::dao::detail::QxSqlIn</a></td><td class="indexvalue">Qx::dao::detail::QxSqlIn : SQL element to verify a list of values (IN, NOT IN, etc.) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_is_between.html">qx::dao::detail::QxSqlIsBetween</a></td><td class="indexvalue">Qx::dao::detail::QxSqlIsBetween : SQL element to verify if a value is included into 2 other values </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_is_null.html">qx::dao::detail::QxSqlIsNull</a></td><td class="indexvalue">Qx::dao::detail::QxSqlIsNull : SQL element to verify if a value is null or not null (IS NULL, IS NOT NULL) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_limit.html">qx::dao::detail::QxSqlLimit</a></td><td class="indexvalue">Qx::dao::detail::QxSqlLimit : SQL element to limit rows count fetched from database </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_sql_query.html">qx::QxSqlQuery</a></td><td class="indexvalue">Qx::QxSqlQuery : define a user SQL query added to default SQL query builded by QxOrm library, and used by qx::dao::xxx functions to filter elements fetched from database </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_sql_query_builder.html">qx::QxSqlQueryBuilder&lt; T &gt;</a></td><td class="indexvalue">Qx::QxSqlQueryBuilder&lt;T&gt; : concrete SQL query builder for the class T with a cache mechanism to backup and restore queries already builded by the program </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_sql_relation.html">qx::QxSqlRelation&lt; DataType, Owner &gt;</a></td><td class="indexvalue">Qx::QxSqlRelation&lt;DataType, Owner&gt; : base class for all relationships defined between 2 classes (or between 2 tables in database) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_sql_relation___many_to_many.html">qx::QxSqlRelation_ManyToMany&lt; DataType, Owner &gt;</a></td><td class="indexvalue">Qx::QxSqlRelation_ManyToMany&lt;DataType, Owner&gt; : manage a relationship many-to-many defined between 2 classes (or between 2 tables in database) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_sql_relation___many_to_one.html">qx::QxSqlRelation_ManyToOne&lt; DataType, Owner &gt;</a></td><td class="indexvalue">Qx::QxSqlRelation_ManyToOne&lt;DataType, Owner&gt; : manage a relationship many-to-one defined between 2 classes (or between 2 tables in database) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_sql_relation___one_to_many.html">qx::QxSqlRelation_OneToMany&lt; DataType, Owner &gt;</a></td><td class="indexvalue">Qx::QxSqlRelation_OneToMany&lt;DataType, Owner&gt; : manage a relationship one-to-many defined between 2 classes (or between 2 tables in database) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_sql_relation___one_to_one.html">qx::QxSqlRelation_OneToOne&lt; DataType, Owner &gt;</a></td><td class="indexvalue">Qx::QxSqlRelation_OneToOne&lt;DataType, Owner&gt; : manage a relationship one-to-one defined between 2 classes (or between 2 tables in database) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_sql_relation_linked.html">qx::QxSqlRelationLinked</a></td><td class="indexvalue">Qx::QxSqlRelationLinked : hierarchy of relationships to build SQL query </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_sql_relation_params.html">qx::QxSqlRelationParams</a></td><td class="indexvalue">Qx::QxSqlRelationParams : define list of parameters to transfer to relationships to manage SQL queries builded by QxOrm library </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_sql_query_1_1_qx_sql_result.html">qx::QxSqlQuery::QxSqlResult</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1detail_1_1_qx_sql_sort.html">qx::dao::detail::QxSqlSort</a></td><td class="indexvalue">Qx::dao::detail::QxSqlSort : SQL element to sort or to group list of elements fetched from database (ORDER BY, GROUP BY) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1cvt_1_1detail_1_1_qx_string_cvt___from_string.html">qx::cvt::detail::QxStringCvt_FromString&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1cvt_1_1detail_1_1_qx_string_cvt___from_variant.html">qx::cvt::detail::QxStringCvt_FromVariant&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1cvt_1_1detail_1_1_qx_string_cvt___to_string.html">qx::cvt::detail::QxStringCvt_ToString&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1cvt_1_1detail_1_1_qx_string_cvt___to_variant.html">qx::cvt::detail::QxStringCvt_ToVariant&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1cvt_1_1detail_1_1_qx_string_cvt_container.html">qx::cvt::detail::QxStringCvtContainer&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1cvt_1_1detail_1_1_qx_string_cvt_enum.html">qx::cvt::detail::QxStringCvtEnum&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1cvt_1_1detail_1_1_qx_string_cvt_generic.html">qx::cvt::detail::QxStringCvtGeneric&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1cvt_1_1detail_1_1_qx_string_cvt_helper.html">qx::cvt::detail::QxStringCvtHelper&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1cvt_1_1detail_1_1_qx_string_cvt_ptr.html">qx::cvt::detail::QxStringCvtPtr&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1cvt_1_1detail_1_1_qx_string_cvt_registered.html">qx::cvt::detail::QxStringCvtRegistered&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1service_1_1_qx_thread.html">qx::service::QxThread</a></td><td class="indexvalue">Qx::service::QxThread : thread to execute a transaction of <a class="el" href="classqx_1_1service_1_1_qx_service.html" title="qx::service::QxService&lt;INPUT, OUTPUT&gt; : concrete service class with INPUT parameters and OUTPUT param...">QxService</a> module </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1service_1_1_qx_thread_pool.html">qx::service::QxThreadPool</a></td><td class="indexvalue">Qx::service::QxThreadPool : thread-safe thread pool to manage list of threads for executing all transactions of <a class="el" href="classqx_1_1service_1_1_qx_service.html" title="qx::service::QxService&lt;INPUT, OUTPUT&gt; : concrete service class with INPUT parameters and OUTPUT param...">QxService</a> module </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_time_neutral.html">qx::QxTimeNeutral</a></td><td class="indexvalue">Qx::QxTimeNeutral : helper class to store a time value into database under neutral format (HHMMSS) =&gt; cross database compatibility </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1service_1_1_qx_tools.html">qx::service::QxTools</a></td><td class="indexvalue">Qx::service::QxTools : provide some tools to read/write on socket all datas transfered by <a class="el" href="classqx_1_1service_1_1_qx_service.html" title="qx::service::QxService&lt;INPUT, OUTPUT&gt; : concrete service class with INPUT parameters and OUTPUT param...">QxService</a> module of QxOrm library </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1service_1_1_qx_transaction.html">qx::service::QxTransaction</a></td><td class="indexvalue">Qx::service::QxTransaction : transaction of <a class="el" href="classqx_1_1service_1_1_qx_service.html" title="qx::service::QxService&lt;INPUT, OUTPUT&gt; : concrete service class with INPUT parameters and OUTPUT param...">QxService</a> module (contains request from client and reply from server) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_validator.html">qx::QxValidator&lt; Owner &gt;</a></td><td class="indexvalue">Qx::QxValidator&lt;Owner&gt; : concrete class for a custom validator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1validator_1_1detail_1_1_qx_validator___helper.html">qx::validator::detail::QxValidator_Helper&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1validator_1_1detail_1_1_qx_validator___helper___container.html">qx::validator::detail::QxValidator_Helper_Container&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1validator_1_1detail_1_1_qx_validator___helper___generic.html">qx::validator::detail::QxValidator_Helper_Generic&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1validator_1_1detail_1_1_qx_validator___helper___ptr.html">qx::validator::detail::QxValidator_Helper_Ptr&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_validator___recursive.html">qx::QxValidator_Recursive&lt; DataType, Owner &gt;</a></td><td class="indexvalue">Qx::QxValidator_Recursive&lt;DataType, Owner&gt; : concrete class for a recursive validator </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_validator___with_data_type.html">qx::QxValidator_WithDataType&lt; DataType, Owner &gt;</a></td><td class="indexvalue">Qx::QxValidator_WithDataType&lt;DataType, Owner&gt; : concrete class for a custom validator with data type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_validator_x.html">qx::QxValidatorX&lt; T &gt;</a></td><td class="indexvalue">Qx::QxValidatorX&lt;T&gt; : concrete class for a list of validators associated to a type registered into QxOrm context </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_repository_1_1qx_verify_pointer.html">qx::QxRepository&lt; T &gt;::qxVerifyPointer&lt; bIsQObject, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1_qx_repository_1_1qx_verify_pointer_3_01true_00_01dummy_01_4.html">qx::QxRepository&lt; T &gt;::qxVerifyPointer&lt; true, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_xml.html">qx::QxXml&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_xml_reader.html">qx::QxXmlReader</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1_qx_xml_writer.html">qx::QxXmlWriter</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1trait_1_1remove__attr.html">qx::trait::remove_attr&lt; T, bRemovePtr, bRemoveConst, bRemoveRef, bRemoveVolatile &gt;</a></td><td class="indexvalue">Qx::trait::remove_attr&lt;T&gt;::type : return a type without pointer, const, reference and/or volatile attributes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1remove__smart__ptr.html">qx::trait::remove_smart_ptr&lt; T &gt;</a></td><td class="indexvalue">Qx::trait::remove_smart_ptr&lt;T&gt;::type : return a type without smart-pointer attribute from boost, Qt or QxOrm library </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1remove__smart__ptr_3_01boost_1_1intrusive__ptr_3_01_t_01_4_01_4.html">qx::trait::remove_smart_ptr&lt; boost::intrusive_ptr&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1remove__smart__ptr_3_01boost_1_1scoped__ptr_3_01_t_01_4_01_4.html">qx::trait::remove_smart_ptr&lt; boost::scoped_ptr&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1remove__smart__ptr_3_01boost_1_1shared__ptr_3_01_t_01_4_01_4.html">qx::trait::remove_smart_ptr&lt; boost::shared_ptr&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1remove__smart__ptr_3_01_q_shared_pointer_3_01_t_01_4_01_4.html">qx::trait::remove_smart_ptr&lt; QSharedPointer&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1remove__smart__ptr_3_01qx_1_1dao_1_1ptr_3_01_t_01_4_01_4.html">qx::trait::remove_smart_ptr&lt; qx::dao::ptr&lt; T &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1serialization_1_1detail_1_1saver.html">qx::serialization::detail::saver&lt; Archive, T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1dao_1_1sql__error.html">qx::dao::sql_error</a></td><td class="indexvalue">Qx::dao::sql_error : define a SQL error exception and retrieve QSqlError type of Qt library </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1dao_1_1sql__join.html">qx::dao::sql_join</a></td><td class="indexvalue">Qx::dao::sql_join : define how to join 2 tables into SQL query (LEFT OUTER JOIN, INNER JOIN, etc...) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1memory_1_1static__mem__pool.html">qx::memory::static_mem_pool&lt; _Sz, _Gid &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1memory_1_1static__mem__pool__set.html">qx::memory::static_mem_pool_set</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1dao_1_1strategy.html">qx::dao::strategy</a></td><td class="indexvalue">Qx::dao::strategy : class inheritance strategy and database (Concrete Table Inheritance is the default strategy used by QxOrm library) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1validator_1_1detail_1_1_qx_validator___helper___container_1_1validate_item___helper.html">qx::validator::detail::QxValidator_Helper_Container&lt; T &gt;::validateItem_Helper&lt; U, bIsPointer &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1validator_1_1detail_1_1_qx_validator___helper___container_1_1validate_item___helper_cef725670d8c969a7e8c9a87e0e9c188.html">qx::validator::detail::QxValidator_Helper_Container&lt; T &gt;::validateItem_Helper&lt; const QPair&lt; U1, U2 &gt;, false &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1validator_1_1detail_1_1_qx_validator___helper___container_1_1validate_item___helper_5d3e08a8f29e482a7c90d91307582e66.html">qx::validator::detail::QxValidator_Helper_Container&lt; T &gt;::validateItem_Helper&lt; const std::pair&lt; U1, U2 &gt;, false &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1validator_1_1detail_1_1_qx_validator___helper___container_1_1validate_item___helper_3a3096badb398822edf9bdbe66b283b4.html">qx::validator::detail::QxValidator_Helper_Container&lt; T &gt;::validateItem_Helper&lt; QPair&lt; U1, U2 &gt;, false &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1validator_1_1detail_1_1_qx_validator___helper___container_1_1validate_item___helper_0bdd7bf94df818f6247208a18ef0b08d.html">qx::validator::detail::QxValidator_Helper_Container&lt; T &gt;::validateItem_Helper&lt; std::pair&lt; U1, U2 &gt;, false &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1validator_1_1detail_1_1_qx_validator___helper___container_1_1validate_item___helper_3_01_u_00_01false_01_4.html">qx::validator::detail::QxValidator_Helper_Container&lt; T &gt;::validateItem_Helper&lt; U, false &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classqx_1_1validator__error.html">qx::validator_error</a></td><td class="indexvalue">Qx::validator_error : define a validator error exception (for example, inserting or updating an element into database) and retrieve list of invalid values </td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container__item_1_1value__qx___helper.html">qx::trait::generic_container_item&lt; Key, Value &gt;::value_qx_Helper&lt; bIsPointer, T, U, dummy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structqx_1_1trait_1_1generic__container__item_1_1value__qx___helper_3_01false_00_01_t_00_01_u_00_01dummy_01_4.html">qx::trait::generic_container_item&lt; Key, Value &gt;::value_qx_Helper&lt; false, T, U, dummy &gt;</a></td><td class="indexvalue"></td></tr>
</table>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Mar 21 2013 11:17:06 for QxOrm by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
